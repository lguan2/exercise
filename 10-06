#298

public int longest(TreeNode root){
	if(root == null) return 0;
	TreeNode left = longest(root.left);
	TreeNode right = longest(root.right);
	int res = 1;
	if(root.left != null && root.val+1 == left.val){
		res = 1 + left;
	}
	if(root.right != null && root.val+1 == right.val){
		res = Math.max(res, 1 + right);
	}
	return res;
}

---------


class MyCalendar{
	TreeMap<Integer, Integer> map;
	public MyCalendar(){
		map = new TreeMap<>();
	}
	public boolean book(int start, int end){
		if(set.isEmpty()){
			map.put(start, end);
			return true;
		}
		Map.Entry ceilingEntry = map.ceilingEntry(start);
		Map.Entry floorEntry = map.floorEntry(start);
		if(ceilingEntry != null && ceilingEntry.getKey() < end) return false;
		if(floorEntry != null && floorEntry.getValue() > start) return false;
		map.put(start, end);
		return true;
	}
}

------

class MyCalendarTwo{
	List<int[]> overlaps;
	List<int[]> books;
	public MyCalendarTwo(){
		this.overlaps = new ArrayList<>();
		this.books = new ArrayList<>();
	}


	public boolean book(int start, int end){
		if(books.isEmpty()){
			books.add(new int[]{start, end});
			return true;
		}
		for(int[] overlap : overlaps){
			if(Math.max(overlap[0], start) > Math.min(overlap[1], end)){
				return false;
			}
		}
		for(int[] book : books){
			if(Math.max(book[0], start) > Math.min(book[1], end)){
				overlaps.add(new int[]{Math.min(book[0], start), Math.min(book[1], end)});
			}
		}
		books.add(new int[]{start, end});
		return true;
	}
}


class MyCalendarTwo{
	List<int[]> overlaps;
	List<int[]> books;
	public MyCalendarTwo(){
		this.overlaps = new ArrayList<>();
		this.books = new ArrayList<>();
	}


	public boolean book(int start, int end){
		if(books.isEmpty()){
			books.add(new int[]{start, end});
			return true;
		}
		for(int[] overlap : overlaps){
			if(Math.max(overlap[0], start) < Math.min(overlap[1], end)){
				return false;
			}
		}
		for(int[] book : books){
			if(Math.max(book[0], start) < Math.min(book[1], end)){
				overlaps.add(new int[]{Math.max(book[0], start), Math.min(book[1], end)});
			}
		}
		books.add(new int[]{start, end});
		return true;
	}
}

------
